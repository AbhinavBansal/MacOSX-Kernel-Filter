/*
 *  DldServiceProtection.cpp
 *  DeviceLock
 *
 *  Created by Slava on 4/06/12.
 *  Copyright 2012 Slava Imameev. All rights reserved.
 *
 */

#include <sys/proc.h>
#include <sys/vm.h>
#include "DldKernAuthorization.h"
#include "DldMacPolicy.h"
#include "DldIOUserClient.h"
#include "DldKernelToUserEvents.h"

//--------------------------------------------------------------------

#define super DldMacPolicy
OSDefineMetaClassAndStructors( DldServiceProtection, DldMacPolicy)

//--------------------------------------------------------------------

bool DldServiceProtection::mpcInit = false;

struct mac_policy_ops DldServiceProtection::mpoServiceProtection;
struct mac_policy_conf DldServiceProtection::mpcServiceProtection;

//--------------------------------------------------------------------

extern "C" {
    
    //
    // to get access to exported private Apple functions load the driver with
    // a dependency key ( kextload -d ) with a name of the pseudo kernel extensions
    // generated by the following script
    /*
     #!/bin/bash
     NAME=/work/DLPrivate
     nm -gj /mach_kernel > allsymbols
     echo "_mac_proc_set_enforce" > ${NAME}.exports
     echo "_proc_iterate" >> ${NAME}.exports
     echo "_proc_lock" >> ${NAME}.exports
     echo "_proc_unlock" >> ${NAME}.exports
     # include any more symbols needed.
     
     kextsymboltool -arch i386 -import allsymbols  -export ${NAME}.exports -output ${NAME}_32
     # if you are making a universal kext for SL
     kextsymboltool -arch x86_64 -import allsymbols -export ${NAME}.exports -output ${NAME}_64
     lipo -create ${NAME}_32 ${NAME}_64 -output ${NAME}
     #lipo -create ${NAME}_32 -output ${NAME}
     */
    
    /* defns for proc_iterate, borrowed from the kernel sources' proc_internal.h */
    #define PROC_ALLPROCLIST        1		/* walk the allproc list (procs not exited yet) */
    #define PROC_ZOMBPROCLIST       2		/*  walk the zombie list */
    #define PROC_NOWAITTRANS        4		/* do not wait for transitions (checkdirs only)  */
    
    /* return values of the proc iteration callback routine, borrowed from the kernel sources' proc_internal.h */ 
    #define PROC_RETURNED           0
    #define PROC_RETURNED_DONE      1
    #define PROC_CLAIMED            2
    #define PROC_CLAIMED_DONE       3
    
    //
    // mac_proc_set_enforce is a private Apple function,
    // should be called with a locked process
    //
    void mac_proc_set_enforce(proc_t p, int enforce_flags);
    
    //
    // proc_iterate is an internal function, use it with caution
    //
    int proc_iterate(int flags, int (*callout)(proc_t , void *), void *arg, int (*filterfn)(proc_t , void *), void *filterarg);
    
    //
    // proc_lock is an internal function, use it with caution
    //
    void proc_lock(proc_t p);
    void proc_unlock(proc_t p);
}

//--------------------------------------------------------------------

bool DldServiceProtection::init()
{
    if( !super::init() ){
        
        DBG_PRINT_ERROR(("super::init() failed\n"));
        return false;
    }
    
    //
    // static variables initialization,
    // the initialization is not thread safe!
    //
    if( !DldServiceProtection::mpcInit ){
        
        DldServiceProtection::mpoServiceProtection.mpo_proc_check_signal         = &DldServiceProtection::procCheckSignal;
        DldServiceProtection::mpoServiceProtection.mpo_proc_check_get_task       = &DldServiceProtection::procCheckGetTask;
        DldServiceProtection::mpoServiceProtection.mpo_cred_label_associate_fork = &DldServiceProtection::credLabelAssociateFork;
        
        DldServiceProtection::mpcServiceProtection.mpc_name               = "DLSERV";
        DldServiceProtection::mpcServiceProtection.mpc_fullname           = "DeviceLock Service Protection";
        DldServiceProtection::mpcServiceProtection.mpc_field_off          = NULL;		/* no label slot */
        DldServiceProtection::mpcServiceProtection.mpc_labelnames         = NULL;		/* no policy label names */
        DldServiceProtection::mpcServiceProtection.mpc_labelname_count    = 0;		/* count of label names is 0 */
        DldServiceProtection::mpcServiceProtection.mpc_ops                = &DldServiceProtection::mpoServiceProtection;	/* policy operations */
        DldServiceProtection::mpcServiceProtection.mpc_loadtime_flags     = 0;
        DldServiceProtection::mpcServiceProtection.mpc_runtime_flags      = 0;
        
        //
        // mark already started processes as under the MAC policy
        //
        proc_iterate( PROC_ALLPROCLIST, DldServiceProtection::processIterateCallout, NULL, NULL, NULL );
        
        DldServiceProtection::mpcInit = true;
    }
    
    this->protectedProcesses = OSArray::withCapacity( 0x1 );
    assert( this->protectedProcesses );
    if( !this->protectedProcesses ){
        
        DBG_PRINT_ERROR(("this->protectedProcesses = OSArray::withCapacity( 0x1 ) failed\n"));
        return false;
    }
    
    this->protectedProcessesLock = IORWLockAlloc();
    assert( this->protectedProcessesLock );
    if( !this->protectedProcessesLock ){
        
        DBG_PRINT_ERROR(("this->protectedProcessesLock = IORWLockAlloc() failed\n"));
        return false;
    }
    
    this->protectedFiles = OSDictionary::withCapacity( 0x4 );
    assert( this->protectedFiles );
    if( !this->protectedFiles ){
        
        DBG_PRINT_ERROR(("this->protectedFiles = OSDictionary::withCapacity( 0x4 ) failed\n"));
        return false;
    }
    
    this->protectedFilesLock = IORWLockAlloc();
    assert( this->protectedFilesLock );
    if( !this->protectedFilesLock ){
        
        DBG_PRINT_ERROR(("this->protectedFilesLock = IORWLockAlloc() failed\n"));
        return false;
    }
    
    return true;
}

//--------------------------------------------------------------------

void DldServiceProtection::free()
{
    this->stopProtection();
    
    if( this->protectedProcesses )
        this->protectedProcesses->release();
    
    if( this->protectedProcessesLock )
        IORWLockFree( this->protectedProcessesLock );
    
    if( this->protectedFiles )
        this->protectedFiles->release();
    
    if( this->protectedFilesLock )
        IORWLockFree( this->protectedFilesLock );
    
    super::free();
}

//--------------------------------------------------------------------

DldServiceProtection* DldServiceProtection::createServiceProtectionObject()
{
    
    assert( preemption_enabled() );
    
    DldServiceProtection* newObject = new DldServiceProtection();
    assert( newObject );
    if( ! newObject ){
        
        DBG_PRINT_ERROR(("new DldServiceProtection() failed\n"));
        return NULL;
    }
    
    if( !newObject->initWithPolicyConf( &DldServiceProtection::mpcServiceProtection, NULL ) ){
        
        DBG_PRINT_ERROR(("newObject->initWithPolicyConf() failed\n"));
        newObject->release();
        return NULL;
    }
    
    bzero( &newObject->adminSettings, sizeof( newObject->adminSettings ) );
    newObject->adminSettings.EnableDefaultSecurity = 0x1;
    
    assert( DldServiceProtection::mpcInit );
    
    return newObject;
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::startProtection()
{
    IOReturn err;
    
    err = this->registerMacPolicy();
    assert( KERN_SUCCESS == err );
    if( KERN_SUCCESS != err ){
        
        DBG_PRINT_ERROR(("this->registerMacPolicy() failed with err = %d\n", err));
        return err;
    }
    
    //
    // the MAC policy for Mac OS X doesn't provide callbacks for ptrace system call, the KAUTH policy is used instead
    //
    
    this->kauthProcessListener = kauth_listen_scope( KAUTH_SCOPE_PROCESS,                            // for the vnode scope
                                                     DldServiceProtection::KauthSopeProcessCallback, // using this callback
                                                     this );                                         // give a cookie to callback
    
    if( NULL == this->kauthProcessListener ){
        
        DBG_PRINT_ERROR( ( "kauth_listen_scope failed for KAUTH_SCOPE_PROCESS\n" ) );
        
        //
        // undo the MAC policy registration
        //
        this->unRegisterMacPolicy();
        
        err = kIOReturnInternalError;
        return err;
    }
    
    assert( KERN_SUCCESS == err );
    return err;
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::stopProtection()
{
    //
    // unregister the scope listener
    //
    if( this->kauthProcessListener )
        kauth_unlisten_scope( this->kauthProcessListener );
    
    return unRegisterMacPolicy();
}

//--------------------------------------------------------------------

static volatile SInt32 gSigkillCounter = 0x0;
static proc_t  gTestProcToProtect = NULL;

/*
 FYI, a call stack for the callback
 
 by calling a kill() system call
 
 #0  DldServiceProtection::procCheckSignal (cred=0x5938d4c, proc=0x736f540, signum=15) at /work/DL_MacSvn/mac/dl-0.x.beta/mac/dl-0.x/DLDriver/DldServiceProtection.cpp:124
 #1  0x005798e8 in mac_proc_check_signal (curp=0x673c2a0, proc=0x736f540, signum=15) at /SourceCache/xnu/xnu-1504.7.4/security/mac_process.c:413
 #2  0x00483f2c in cansignal (p=0x673c2a0, uc=0x5938d4c, q=0x736f540, signum=15, zombie=0) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:299
 #3  0x00484eba in kill (cp=0x673c2a0, uap=0x6672de8, retval=0x66678f4) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:1417
 #4  0x004edaf8 in unix_syscall64 (state=0x6672de4) at /SourceCache/xnu/xnu-1504.7.4/bsd/dev/i386/systemcalls.c:433 
 
 OR on system shutdown
 
 #0  DldServiceProtection::procCheckSignal (cred=0x59382e4, proc=0x67102a0, signum=1) at /work/DL_MacSvn/mac/dl-0.x.beta/mac/dl-0.x/DLDriver/DldServiceProtection.cpp:124
 #1  0x005798e8 in mac_proc_check_signal (curp=0x67102a0, proc=0x67102a0, signum=1) at /SourceCache/xnu/xnu-1504.7.4/security/mac_process.c:413
 #2  0x00483f2c in cansignal (p=0x67102a0, uc=0x59382e4, q=0x67102a0, signum=1, zombie=0) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:299
 #3  0x00484fcc in killpg1_callback (p=0x67102a0, arg=0x31ea3f0c) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:1490
 #4  0x0047dfc8 in pgrp_iterate (pgrp=0x5b508a0, flags=<value temporarily unavailable, due to optimizations>, callout=0x484f77 <killpg1_callback>, arg=0x31ea3f0c, filterfn=0x4821c2 <killpg1_pgrpfilt>, filterarg=0x0) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_proc.c:2147
 #5  0x0048320e in killpg1 (cp=0x67102a0, signum=1, pgid=0, all=0, posix=1) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:1556
 #6  0x00484f46 in kill (cp=0x67102a0, uap=0x66724e8, retval=0x6666974) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_sig.c:1432
 #7  0x004edaf8 in unix_syscall64 (state=0x66724e4) at /SourceCache/xnu/xnu-1504.7.4/bsd/dev/i386/systemcalls.c:433
 */
int DldServiceProtection::procCheckSignal( kauth_cred_t cred,
                                           struct proc *proc,
                                           int signum )
{
    assert( preemption_enabled() );
    assert( gServiceProtection );
    
    int error = 0x0; // by default grant the access
    
    if( gServiceProtection->useDefaultSystemSecurity() ){
        
        //
        // the system enforces the process protection
        //
        return 0x0;
    }
    
    if( current_proc() == proc ){
        
        //
        // allow to send any signal itself
        //
        return 0x0;
    }
    
    if( SIGKILL == signum ||
        SIGTERM == signum ||
        SIGQUIT == signum ||
        SIGINT  == signum ){
        
        OSIncrementAtomic( &gSigkillCounter );
        
        DldProtectedProcess* protectedProcess;
        
        protectedProcess = gServiceProtection->getProtectedProcessRef( proc_pid( proc ) );
        if( protectedProcess ){
            
            if( !gServiceProtection->isAccessAllowed( protectedProcess->getAclObject(), DL_PROCESS_TERMINATE, cred ) )
                error = EPERM;
            
            protectedProcess->release();
        }
        
        /*if( gTestProcToProtect == proc )
            error = EPERM;*/
        
        
        DldIOUserClient* userClient = gServiceProtection->getUserClient();
        if( userClient ){
            
            //
            // report to the service
            //
            DldDriverEventData  event;
            
            bzero( &event, sizeof( event ) );
            
            event.Header.id = gKerneToUserEvents.getNextEventNumber();
            event.Header.size = sizeof( event );
            event.Header.type = DLD_EVENT_SIGNAL;
            
            event.Tail.Signal.signum = signum;
            event.Tail.Signal.senderPid = proc_pid( current_proc() );
            event.Tail.Signal.receiverPid = proc_pid( proc );
            event.Tail.Signal.deliveryRejected = ( 0x0 != error );
            
            userClient->eventNotification( &event );
            
            gServiceProtection->releaseUserClient();
        }
        
    } // end if( SIGKILL == signum || SIGTERM == signum )
    
    return error;
}

//--------------------------------------------------------------------

int DldServiceProtection::procCheckGetTask( kauth_cred_t cred,
                                            struct proc *proc )
{
    assert( preemption_enabled() );
    assert( gServiceProtection );
    
    int error = 0x0; // by default grant the access
    
    if( gServiceProtection->useDefaultSystemSecurity() ){
        
        //
        // the system enforces the process protection
        //
        return 0x0;
    }
    
    if( current_proc() == proc ){
        
        //
        // allow access to itself
        //
        return 0x0;
    }
    
    if( 0x1 == proc_pid( current_proc() ) ){
        
        //
        // allow launchd to get a process port, an attempt to kill the process will be caught by procCheckSignal,
        // but launchd will be able to write in the process memory
        //
        return 0x0;
    }
    
    DldProtectedProcess* protectedProcess;
    
    protectedProcess = gServiceProtection->getProtectedProcessRef( proc_pid( proc ) );
    if( protectedProcess ){
        
        if( !gServiceProtection->isAccessAllowed( protectedProcess->getAclObject(), DL_PROCESS_TERMINATE, cred ) )
            error = EPERM;
        
        protectedProcess->release();
    }
    
    /*if( gTestProcToProtect == proc )
        error = EPERM;*/
    
    return error;
}

//--------------------------------------------------------------------

int DldServiceProtection::KauthSopeProcessCallback(
    kauth_cred_t _credential,
    void *_idata,
    kauth_action_t _action,
    uintptr_t _arg0,
    uintptr_t _arg1,
    uintptr_t _arg2,
    uintptr_t _arg3
    )
/*
 the callback is called from the ptrace system call by calling
 kauth_authorize_process(proc_ucred(p), KAUTH_PROCESS_CANTRACE, 
 t, (uintptr_t)&err, 0, 0) where t is a target BSD process,
 *err is an error returned if the access is denied

  current_proc() - process that will do the tracing 
  arg0 - process to be traced 
  arg1 - pointer to int - reason (errno) for denial 
 */
{
    int error = 0x0;
    
    DldProtectedProcess* protectedProcess;
    
    switch( _action ){
            
        case KAUTH_PROCESS_CANTRACE:
        {
            protectedProcess = gServiceProtection->getProtectedProcessRef( proc_pid( (proc_t)_arg0 ) );
            if( protectedProcess ){
                
                if( !gServiceProtection->isAccessAllowed( protectedProcess->getAclObject(), DL_PROCESS_TERMINATE, _credential ) )
                    error = EPERM;
                
                protectedProcess->release();
            }
            break;
        } // end case KAUTH_PROCESS_CANTRACE
        default:
            break;
    } // end switch( action )
    
    *(unsigned int*)_arg1 = error;
    
    return ( 0x0 != error) ? KAUTH_RESULT_DENY : KAUTH_RESULT_DEFER;
}

//--------------------------------------------------------------------

static volatile SInt32 gForkCounter = 0x0;

/*
 FYI, a usual call stack
 #0  DldServiceProtection::credLabelAssociateFork (cred=0x5938b90, proc=0x78872a0) at /work/DL_MacSvn/mac/dl-0.x.beta/mac/dl-0.x/DLDriver/DldServiceProtection.cpp:139
 #1  0x00578f53 in mac_cred_label_associate_fork (cred=0x5938b90, proc=0x78872a0) at /SourceCache/xnu/xnu-1504.7.4/security/mac_process.c:158
 #2  0x00478fd6 in fork1 (parent_proc=0x6755a80, child_threadp=0x320bbf5c, kind=0) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_fork.c:556
 #3  0x00479113 in fork (parent_proc=0x6755a80, uap=0x6680dc8, retval=0x6fb2a64) at /SourceCache/xnu/xnu-1504.7.4/bsd/kern/kern_fork.c:861
 #4  0x004edaf8 in unix_syscall64 (state=0x6680dc4) at /SourceCache/xnu/xnu-1504.7.4/bsd/dev/i386/systemcalls.c:433
 
 I use this callback to track the fork and vfork system calls. Actually, there is a back door left - a natural Mach
 task creation by calling task_create() and then thread_create() native Mach API's functions, a created task will
 not be associated with BSD proc structure and can't be controlled by MAC framework. So we are still vulnerable to
 a native Mach API attack.
 */
void DldServiceProtection::credLabelAssociateFork( kauth_cred_t cred,
                                                   proc_t proc )
{
    assert( preemption_enabled() );
    
    OSIncrementAtomic( &gForkCounter );
    
    //
    // the process lock acquiring is not nedded as the process is not visible at this stage
    //
    mac_proc_set_enforce( proc, MAC_PROC_ENFORCE );
}

//--------------------------------------------------------------------

int DldServiceProtection::processIterateCallout( __in proc_t proc, __in void* context )
{
    assert( preemption_enabled() );
    
    if( 0x0 == proc_pid( proc ) ){
        
        //
        // skip it, this is a kernel process
        //
        return PROC_RETURNED;
    }
    
    //
    // the process lock acquiring is needed
    //
    proc_lock( proc );
    { // start of the lock
        mac_proc_set_enforce( proc, MAC_PROC_ENFORCE );
    } // end of the lock
    proc_unlock( proc );
    
    return PROC_RETURNED;
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::setProcessSecurity( __in pid_t  pid, __in_opt DldAclObject* acl )
{
    assert( preemption_enabled() );
    
    DldProtectedProcess*  newProtProcess;
    newProtProcess = DldProtectedProcess::withPidAndAcl( pid, acl );
    assert( newProtProcess );
    if( !newProtProcess ){
        
        DBG_PRINT_ERROR(("DldProtectedProcess::withPidAndAcl() failed\n"));
        return kIOReturnNoMemory;
    } // end if( !newProtProcess )
    
    assert( this->protectedProcessesLock );
    assert( this->protectedProcesses );
    
    IOReturn  status = KERN_SUCCESS;
    IORWLockWrite( this->protectedProcessesLock );
    { // start of the lock
        
        //
        // remove the old object, if it exists
        //
        unsigned int oldIndex = (unsigned int)(-1);
        DldProtectedProcess* oldObj = this->getProtectedProcessDscrByPidWithoutLock( pid, &oldIndex );
        if( oldObj ){
            
            assert( oldIndex < this->protectedProcesses->getCount() );
            
            this->protectedProcesses->removeObject( oldIndex );
            DLD_DBG_MAKE_POINTER_INVALID( oldObj ); // the object was released when was being removed from the array
            oldIndex = (unsigned int)(-1);
        } // end if( oldObj )
        
        //
        // add the new object in the array
        //
        if( ! this->protectedProcesses->setObject( newProtProcess ) ){
            
            assert( !"this->protectedProcesses->setObject( newProtProcess )" );
            DBG_PRINT_ERROR(("this->protectedProcesses->setObject( newProtProcess ) failed\n"));
            status = kIOReturnNoMemory;
        }
            
        //
        // the object is referenced by the array, release the reference returned by the creation function
        //
        newProtProcess->release();
        DLD_DBG_MAKE_POINTER_INVALID( newProtProcess );
        
    } // end of the lock
    IORWLockUnlock( this->protectedProcessesLock );
    
    return status;
}

//--------------------------------------------------------------------

void DldServiceProtection::removeProcessSecurity( __in pid_t pid )
{
    assert( preemption_enabled() );
    
    IORWLockWrite( this->protectedProcessesLock );
    { // start of the lock
        
        DldProtectedProcess* procObj;
        unsigned int  indexToRemove;
        
        procObj = this->getProtectedProcessDscrByPidWithoutLock( pid, &indexToRemove );
        if( procObj ){
            
            assert( procObj->getPID() == pid && indexToRemove < 0xFFFF );
            this->protectedProcesses->removeObject( indexToRemove );
            DLD_DBG_MAKE_POINTER_INVALID( procObj );
        }
        
    } // end of the lock
    IORWLockUnlock( this->protectedProcessesLock );
}

//--------------------------------------------------------------------

//
// a caller must acquire the lock, a returned object is not referenced
// returns
//  an unreferenced object and its index in the array
// OR
//  NULL and the index is set to (-1)
//
DldProtectedProcess* DldServiceProtection::getProtectedProcessDscrByPidWithoutLock( __in pid_t pid, __out unsigned int* index )
{
    unsigned int objCount = this->protectedProcesses->getCount();
    
    for( unsigned int i = 0x0; i < objCount; ++i ){
        
        DldProtectedProcess*  protectedProcess = OSDynamicCast( DldProtectedProcess, this->protectedProcesses->getObject( i ) );
        assert( protectedProcess );
        
        if( protectedProcess->getPID() == pid ){
            
            *index = i;
            return protectedProcess;
        }
        
    } // end for
    
    *index = (unsigned int)(-1);
    return NULL;
}

//--------------------------------------------------------------------

void DldServiceProtection::removeAllProcessesAndFilesSecurity()
{
    this->adminSettings.EnableDefaultSecurity    = 0x1;
    DldMemoryBarrier();
    this->adminSettings.EnableUnhookProtection   = 0x0;
    this->adminSettings.EnableSysFilesProtection = 0x0;
    this->adminSettings.UseStrongIntegrCheck     = 0x0;
    
    IORWLockWrite( this->protectedProcessesLock );
    { // start of the lock
        
        this->protectedProcesses->flushCollection();
        
    } // end of the lock
    IORWLockUnlock( this->protectedProcessesLock );
    
    IORWLockWrite( this->protectedFilesLock );
    { // start of the lock
        
        this->protectedFiles->flushCollection();
        
    } // end of the lock
    IORWLockUnlock( this->protectedFilesLock );
}

//--------------------------------------------------------------------

DldProtectedProcess* DldServiceProtection::getProtectedProcessRef( __in pid_t pid )
{
    assert( preemption_enabled() );
    
    DldProtectedProcess* procObj;
    
    IORWLockRead( this->protectedProcessesLock );
    { // start of the lock
        
        unsigned int  indexNotUsed;
        
        procObj = this->getProtectedProcessDscrByPidWithoutLock( pid, &indexNotUsed );
        if( procObj ){
            
            assert( procObj->getPID() == pid );
            procObj->retain();
        }
        
    } // end of the lock
    IORWLockUnlock( this->protectedProcessesLock );
    
    return procObj;
}

//--------------------------------------------------------------------

bool DldServiceProtection::isAccessAllowed( __in_opt DldAclObject* aclObject,
                                            __in kauth_ace_rights_t  requestedAccess,
                                            __in kauth_cred_t cred )
{
	struct kauth_acl_eval	    eval = { 0x0 };
	int                         error;
    bool                        deref_cred = false;
    
    assert( preemption_enabled() );
    
    if( this->useDefaultSystemSecurity() ){
        
        //
        // use default system protection
        //
        return true;
    }
    
    if( NULL == aclObject ){
        
        //
        // a NULL ACL - allow access to everyone
        //
        return true;
    }
    
    if( !cred ){
        
        //
        // get the current process credentials
        //
        cred = kauth_cred_proc_ref( current_proc() );
        assert( cred );
        
        deref_cred = true;
        
    }// end if( !cred )
    
    //
    // fill in the evaluation structure
    //
    eval.ae_requested  = requestedAccess;
    eval.ae_acl        = &(aclObject->getAcl()->acl_ace[0]);
    eval.ae_count      = aclObject->getAcl()->acl_entrycount;
    eval.ae_options    = 0;
    //eval.ae_options |= KAUTH_AEVAL_IS_OWNER;
    //eval.ae_options |= KAUTH_AEVAL_IN_GROUP;
    eval.ae_exp_gall   = KAUTH_VNODE_GENERIC_ALL_BITS;     // TO DO - must be DL process rights 
    eval.ae_exp_gread  = KAUTH_VNODE_GENERIC_READ_BITS;    // TO DO - must be DL process rights
    eval.ae_exp_gwrite = KAUTH_VNODE_GENERIC_WRITE_BITS;   // TO DO - must be DL process rights
    eval.ae_exp_gexec  = KAUTH_VNODE_GENERIC_EXECUTE_BITS; // TO DO - must be DL process rights
    
    eval.ae_result = 0xFFFF; // jus for a debug
    
    //
    // evaluate the requested access rights
    //
    error = ::DldKauthAclEvaluate( cred, &eval );
    //assert( !error ); removed as fired on system shutdown
    if( error ){
        
        DBG_PRINT_ERROR(("DldKauthAclEvaluate returned an error %d\n", error));
        eval.ae_result = KAUTH_RESULT_DENY;
        
    }// end if( error )
    
    //
    // if not all requested permissions have been cleared then deny access,
    // the logic is in consisten with the Windows's SeAccessCheck()
    // ( for reference see Programming Windows Security by Keith Brown,
    // pp 198-200 )
    //
    if( KAUTH_RESULT_DEFER == eval.ae_result && 0x0 != eval.ae_residual )
        eval.ae_result = KAUTH_RESULT_DENY;
    
    assert( KAUTH_RESULT_ALLOW == eval.ae_result ||
            KAUTH_RESULT_DENY  == eval.ae_result ||
            KAUTH_RESULT_DEFER == eval.ae_result );
    
    if( deref_cred ){
        
        assert( cred );
        kauth_cred_unref( &cred );
        
    }// end if( deref_cred )
    
    return ( KAUTH_RESULT_DENY != eval.ae_result );
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::setFileSecurity( __in OSString* path,
                                                __in_opt DldAclObject* usersAcl,
                                                __in_opt DldAclWithProcsObject* procsAcl )
{
    //
    // check the path validity, the path should not end on \ even for directories,
    // this is to prevent two paths for a directory ( with and w/o terminating slash ),
    // OSString::getLength() does not account for zero terminator
    //
    if( path->getLength() < 1 || path->getChar( path->getLength() - 1 ) == '/' ){
        
        DBG_PRINT_ERROR(("the path %s is in invalid format\n", path->getCStringNoCopy() ));
        return kIOReturnBadArgument;
    }
    
    IOReturn err = KERN_SUCCESS;
        
    IORWLockWrite( this->protectedFilesLock );
    { // start of the lock
        
        //
        // remove the existing policy for the file
        //
        this->protectedFiles->removeObject( path );
        
        DldProtectedFile* protectedFile = DldProtectedFile::withPathAndAcls( path, usersAcl, procsAcl );
        assert( protectedFile );
        if( !protectedFile ){
            
            DBG_PRINT_ERROR(("DldProtectedFile::withPathAndAcls(%s) failed\n", path->getCStringNoCopy()));
            err = kIOReturnNoMemory;
            
        } else {
            
            //
            // add to the dictionary
            //
            if( ! this->protectedFiles->setObject( path, protectedFile ) ){
                
                err = kIOReturnError;
            }
            
            //
            // and release as the dictionary takes its own reference
            //
            protectedFile->release();
            DLD_DBG_MAKE_POINTER_INVALID( protectedFile );
        }
        
    } // end of the lock
    IORWLockUnlock( this->protectedFilesLock );
    
    //
    // incremet security settings counter
    //
    OSIncrementAtomic( &this->settingsSequenceCounter );
    
    return err;
}

//--------------------------------------------------------------------

DldProtectedFile* DldServiceProtection::getProtectedFileRef( __in const char* path )
{
    size_t pathLen = strlen( path );
    size_t allocatedLen = 0x0;
    
    if( 0x0 == pathLen )
        return NULL;
    
    if( '/' == path[ pathLen - 0x1 ] ){
        
        //
        // remove the terminating / for the directory,
        // the directories are inserted in the dictionary w/o trailing back slash
        //
        allocatedLen = pathLen + sizeof( '\0' );
        char* newPath = (char*)IOMalloc( allocatedLen );
        assert( newPath );
        if( !newPath ){
         
            allocatedLen = 0x0;
            return NULL;
        }
        
        assert( allocatedLen >= pathLen + sizeof( '\0' ) );
        
        bcopy( path, newPath, pathLen + sizeof( '\0' ) );
        
        //
        // now adjust length for a new string
        //
        pathLen -= 0x1;
        newPath[ pathLen ] = '\0'; // this removes the trailing back slash
        assert( newPath[ pathLen - 0x1 ] != '/' );
        
        //
        // swap
        //
        path = newPath;
    } // end if( '/' == path[ pathLen - 0x1 ] )
    
    DldProtectedFile*  protectedFile = NULL;
    
    //
    // iterate through all keys in the protected files dictionairy and check that the path is not a protected one
    //
    IORWLockRead( this->protectedFilesLock );
    { // start of the lock
        
        OSCollectionIterator*  iterator = OSCollectionIterator::withCollection( this->protectedFiles );
        assert( iterator );
        if( iterator ){
            
            OSObject* keyObject;
            
            while( !protectedFile && NULL != (keyObject = iterator->getNextObject()) ){
                
                OSString*  keyString = OSDynamicCast( OSString, keyObject );
                assert( keyString );
                if( keyString ){
                    
                    //
                    // Is this a path to the protected directory or file?
                    // There are two options
                    //  - the exact match with the protected path, case 1
                    //  - a path into the protected directory, case 2
                    //
                    if( keyString->isEqualTo( path ) // case 1
                        ||
                        ( pathLen > keyString->getLength() &&
                          '/' == path[ keyString->getLength() ] && // i.e. this is a protected directory
                          0x0 == strncmp( path, keyString->getCStringNoCopy(), keyString->getLength() ) ) // case 2
                       ){
                        
                        //
                        // now get the protected file object for the path
                        //
                        
                        protectedFile = (DldProtectedFile*)this->protectedFiles->getObject( keyString );
                        assert( protectedFile ); 
                        if( protectedFile )
                            protectedFile->retain();
                        
                    } // end if( keyString->isEqualTo( path ) // case 1
                } // end if( keyString )
            } // end while
            
            iterator->release();
            DLD_DBG_MAKE_POINTER_INVALID( iterator );
        } // end if( itertaor )

    } // end of the lock
    IORWLockUnlock( this->protectedFilesLock );
    
    if( 0x0 != allocatedLen )
        IOFree( (void*)path, allocatedLen );

    return protectedFile;
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::registerUserClient( __in DldIOUserClient* client )
{
    return userClient.registerUserClient( client );
}

//--------------------------------------------------------------------

IOReturn DldServiceProtection::unregisterUserClient( __in DldIOUserClient* client )
{
    return userClient.unregisterUserClient( client );
}

//--------------------------------------------------------------------

bool DldServiceProtection::isUserClientPresent()
{
    return userClient.isUserClientPresent();
}

//--------------------------------------------------------------------

//
// if non NULL value is returned a caller must call releaseUserClient()
// when it finishes with the returned client object
//
DldIOUserClient* DldServiceProtection::getUserClient()
{
    return userClient.getUserClient();
}

//--------------------------------------------------------------------

void DldServiceProtection::releaseUserClient()
{
    userClient.releaseUserClient();
}

//--------------------------------------------------------------------
