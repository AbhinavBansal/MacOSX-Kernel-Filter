/* 
 * Copyright (c) 2010 Slava Imameev. All rights reserved.
 */

#include "DldIOSCSIProtocolInterface.h"
#include "DldSCSITask.h"
#include "DldKernAuthorization.h"
#include "DldSupportingCode.h"
#include "DldIOShadow.h"

//--------------------------------------------------------------------

#define super DldHookerBaseInterface

//--------------------------------------------------------------------

//
// if fase is returned the request has been completed as the access is denied
//
bool
DldIOSCSIProtocolInterface::ExecuteCommand(
    __in IOSCSIProtocolInterface* service,
    __in SCSITaskIdentifier request
    )
{
    //SCSICommandDescriptorBlock   cdb;
    
    //assert( sizeof( cdb ) == kSCSICDBSize_Maximum );
    
    //DldSCSITaskGetCommandDescriptorBlock( request, &cdb );
    
    ///////
    /// start of the test
    /*
      DldSCSITaskCompleteAccessDenied( request );
      return false;
     */
    /// end of the test
    ////////
    /*
    dld_classic_rights_t   access;
    access = DldSCSITaskGetCdbRequestedAccess( request );
    if( 0x0 != ( DEVICE_WRITE & access ) ){
        
        DldSCSITaskCompleteAccessDenied( request );
        return false;
    }*/
    
    
    assert( preemption_enabled() );
    
    DldIOService*             dldSCSIDev;
    DldObjectPropertyEntry*   property;
    dld_classic_rights_t      requestedAccess;
    DldAccessCheckParam       param;
    bool                      disable        = false;
    bool                      isShadowedUser = false;
    
    requestedAccess = DldSCSITaskGetCdbRequestedAccess( request );
    if( 0x0 == requestedAccess )
        return true;
    
    dldSCSIDev = DldIOService::RetrieveDldIOServiceForIOService( service );
    assert( dldSCSIDev );
    if( !dldSCSIDev ){
        
        DBG_PRINT_ERROR(("DldIOService::RetrieveDldIOServiceForIOService( 0x%p ) returned NULL\n", service ));
        return true;
    }
    
    //
    // do not check read operations if there is a CD or DVD object in the stack,
    // as read requests are generated by every client including a mounted FSD( i.e. BSD susbsystem ),
    // but if there is no CD or DVD object then a user mode client dismantled them and
    // attached directly to the SCSI object, in that case the read requests must be 
    // checked and audited
    //
    if( DEVICE_READ == requestedAccess ){
        
        DldObjectPropertyEntry*   media;
        
        //
        // look for actual CD/DVD properties
        //

        media = dldSCSIDev->retrievePropertyByTypeRef( DldObjectPopertyType_IODVDMedia );
        if( NULL == media )
            media = dldSCSIDev->retrievePropertyByTypeRef( DldObjectPopertyType_IOCDMedia );
        
        if( media ){
            
            //
            // a request from the BSD subssytem, the request has been checked by the BSD KAUTH callbacks
            //
            media->release();
            goto __exit;
        }
        
    } // end if( DEVICE_READ == requestedAccess )
    
    property = dldSCSIDev->getObjectProperty();
    if( !property ){
        
        //
        // we are not interested in this device, this means that
        // there is another IOSCSIProtocolInterface device attached
        // to this one and this last is visible for user apps
        //
        goto __exit;
    }
    
    if( DldObjectPopertyType_SCSIPeripheralDeviceType05 != property->dataU.property->typeDsc.type ){
     
        DBG_PRINT_ERROR(("It seems you added a new SCSI type %i but forgot to add its processing\n", property->dataU.property->typeDsc.type ));
        assert( !"It seems you added a new SCSI type but forgot to add its processing" );
        goto __exit;
    }
        
    bzero( &param, sizeof( param ) );
    
    param.userSelectionFlavor = kDefaultUserSelectionFlavor;
    param.aclType             = kDldAclTypeSecurity;
    param.checkParentType     = true;
    param.dldRequestedAccess.winRequestedAccess   = requestedAccess;
    //param.dldRequestedAccess.kauthRequestedAccess = requestedAccess; // TO DO remove when the daemon will be able to proide ACL
    param.credential          = NULL;// current thread's user
    param.dldIOService        = dldSCSIDev;
#if defined(LOG_ACCESS)
    param.sourceFunction      = __PRETTY_FUNCTION__;
    param.sourceFile          = __FILE__;
    param.sourceLine          = __LINE__;
#endif//#if defined(LOG_ACCESS)
    
    /*if( dldIOService->getObjectProperty() &&
     DLD_DEVICE_TYPE_REMOVABLE == dldIOService->getObjectProperty()->dataU.property->deviceType.type.major ){}*/
    
    ::DldAcquireResources( &param );
    {
        ::isAccessAllowed( &param );
        
        disable = ( param.output.access.result[ DldFullTypeFlavor ].disable || 
                    param.output.access.result[ DldMajorTypeFlavor ].disable || 
                    param.output.access.result[ DldParentTypeFlavor ].disable );
        
#if defined( DBG )
        /*if( disable ){
         __asm__ volatile( "int $0x3" );
         }*/
#endif
        
        //
        // should we log?
        //
        if( param.output.access.result[ DldFullTypeFlavor ].log ||
            param.output.access.result[ DldMajorTypeFlavor ].log ){
            
            DldDriverDataLogInt intData;
            DldDriverDataLog    data;
            bool                logDataValid;
            kauth_cred_t        credentials;
            
            intData.logDataSize = sizeof( data );
            intData.logData = &data;
            
            credentials = kauth_cred_proc_ref( current_proc() ); // just like in isAccessAllowed()
            assert( credentials );
            if( credentials ){
                
                logDataValid = dldSCSIDev->initDeviceLogData( &param.dldRequestedAccess,
                                                              (ALL_WRITE & requestedAccess) ? DldFileOperationWrite : DldFileOperationRead,
                                                              proc_pid(current_proc()),
                                                              credentials,
                                                              ( param.output.access.result[ DldFullTypeFlavor ].disable || 
                                                                param.output.access.result[ DldMajorTypeFlavor ].disable ),
                                                              &intData );
                
                assert( logDataValid );
                if( logDataValid ){
                    
                    gLog->logData( &intData );
                    
                } else {
                    
                    DBG_PRINT_ERROR(("device log data is invalid\n"));
                }
                
                kauth_cred_unref( &credentials );
            } else {
                
                DBG_PRINT_ERROR(("kauth_cred_proc_ref failed\n"));
            }
            
        }// end log
    }
    ::DldReleaseResources( &param );
    
    if( !disable ){
        
        //
        // check for ejection
        //
        if( DldSCSITaskIsMediaEjectionRequest( request ) ){
            
            /*
             a media is ejected by calling IOSCSIMultimediaCommandsDevice::EjectTheMedia which in turn
             calls IOSCSIProtocolInterface::ExecuteCommand with two commands - the first unlocks the tray
             and the second is kSCSICmd_START_STOP_UNIT, the stack is as follows
             
             #0  0x015eae43 in IOSCSIMultimediaCommandsDevice::EjectTheMedia (this=0x57c2d00) at /SourceCache/IOSCSIArchitectureModelFamily/IOSCSIArchitectureModelFamily-265.0.3/IOSCSIMultimediaCommands/IOSCSIMultimediaCommandsDevice.cpp:722
             #1  0x015f0cb3 in IODVDServices::doEjectMedia (this=0x57c6380) at /SourceCache/IOSCSIArchitectureModelFamily/IOSCSIArchitectureModelFamily-265.0.3/IOSCSIMultimediaCommands/IODVDServices.cpp:594
             #2  0x011edfd8 in IOBlockStorageDriver::ejectMedia (this=0x57c2200) at /SourceCache/IOStorageFamily/IOStorageFamily-116.1/IOBlockStorageDriver.cpp:1191
             #3  0x011f70ef in dkioctl (dev=234881028, cmd=536896533, data=0x31d93e94 "", flags=1, proc=0x5bf4d20) at /SourceCache/IOStorageFamily/IOStorageFamily-116.1/IOMediaBSDClient.cpp:1382
             #4  0x003662a1 in spec_ioctl (ap=0x31d93d9c) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/miscfs/specfs/spec_vnops.c:529
             #5  0x00357488 in VNOP_IOCTL (vp=0x8f612e4, command=536896533, data=0x31d93e94 "", fflag=1, ctx=0x31d93e8c) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/vfs/kpi_vfs.c:3606
             #6  0x0034ca2f in vn_ioctl (fp=0x63504a0, com=536896533, data=0x31d93e94 "", ctx=0x31d93e8c) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/vfs/vfs_vnops.c:1147
             #7  0x00515c35 in fo_ioctl (fp=0x63504a0, com=536896533, data=0x31d93e94 "", ctx=0x31d93e8c) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/kern/kern_descrip.c:4826
             #8  0x005458ff in ioctl (p=0x5bf4d20, uap=0x54bea28, retval=0x5680324) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/kern/sys_generic.c:914
             #9  0x005b19b5 in unix_syscall64 (state=0x54bea24) at /work/Mac_OS_X_kernel/10_6_4/xnu-1504.7.4/bsd/dev/i386/systemcalls.c:365
             
             a description for the START_STOP_UNIT command can be found here
             http://en.wikipedia.org/wiki/SCSI_Start_Stop_Unit_Command
             we are interested in the following field
             LoEj (load/eject) and Start - these two bits are used together:
             00 - Stop motor
             01 - Start motor
             10 - Eject media
             11 - Load media
             */
            
            //
            // the media is being removed, invalidate the CD/DVD white list state,
            // the FSD has been already unmounted as the tray is locked when FSD
            // is mounted, if the white list results will be removed prematurely
            // when they will be restored on the next request
            //
            
            DldAclObject*  wlACLToRemove;
            
            property->dataU.property->LockExclusive();
            { // start of the lock
                
                wlACLToRemove = property->dataU.property->whiteListState.acl;
                property->dataU.property->whiteListState.acl              = NULL;
                property->dataU.property->whiteListState.inWhiteList      = false;
                property->dataU.property->whiteListState.currentWLApplied = false;// this value is a main driver to start reinitialization
                
                //
                // meaningless for DVD/CD
                //
                assert( false == property->dataU.property->whiteListState.propagateUp );
                
                if( DldObjectPopertyType_SCSIPeripheralDeviceType05 == property->dataU.property->typeDsc.type ){
                    
                    //
                    // the media is being removed
                    //
                    
                    property->dataU.ioSCSIPeripheralType05Property->uidValid = false;
                    
                    bzero( &property->dataU.ioSCSIPeripheralType05Property->mediaUID,
                           sizeof( property->dataU.ioSCSIPeripheralType05Property->mediaUID ) );
                }
                
            }// end of the lock
            property->dataU.property->UnLockExclusive();
            
            if( wlACLToRemove )
                wlACLToRemove->release();
            
            property->setUIDProperty();
            
        }// end if( DldSCSITaskIsMediaEjectionRequest( request )
        
        
        //
        // check for shadowing
        //
        DldAccessCheckParam param;
        
        bzero( &param, sizeof( param ) );
        
        param.userSelectionFlavor = kDefaultUserSelectionFlavor;
        param.aclType             = kDldAclTypeShadow;
        param.checkParentType     = true;
        param.dldRequestedAccess.kauthRequestedAccess = requestedAccess;// actually the value is ignored
        param.credential          = NULL;// current thread's user
        param.service             = NULL;
        param.dldIOService        = dldSCSIDev;
        
        ::DldAcquireResources( &param );
        ::DldIsShadowedUser( &param );
        ::DldReleaseResources( &param );
        
        isShadowedUser = ( param.output.shadow.result[ DldFullTypeFlavor ].shadow || 
                           param.output.shadow.result[ DldMajorTypeFlavor ].shadow || 
                           param.output.shadow.result[ DldParentTypeFlavor ].shadow );
        
    }// end if( !disable )
    
    
    //
    // shadow the write request
    //
    if( isShadowedUser && 0x0 != ( DEVICE_WRITE & requestedAccess ) ){
        
        assert( !disable );
        
        DldCommonShadowParams commonParams;
        UInt32       completionEvent    = DLD_INVALID_EVENT_VALUE;
        IOReturn     shadowCompletionRC = kIOReturnInvalid;
        bool         synchronousShadow  = false;
        bool         shadowed           = false;
        
        if( gSecuritySettings.securitySettings.disableOnShadowErrors ){
            
            //
            // the shadow operation must be synchronous
            //
            synchronousShadow = true;
        }
        
        bzero( &commonParams, sizeof( commonParams ) );
        
        commonParams.operationID = gShadow->generateUniqueID();
        if( synchronousShadow ){
            
            //
            // for synchronous processing we need an event to wait for shadow completion
            //
            DldInitNotificationEvent( &completionEvent );
            commonParams.completionEvent    = &completionEvent;
            commonParams.shadowCompletionRC = &shadowCompletionRC;
        }
        
        //
        // shadow the request
        //
        shadowed = gShadow->shadowSCSIOperation( dldSCSIDev, request, &commonParams );        
        if( shadowed && synchronousShadow ){
            
            //
            // wait for shadow completion
            //
            DldWaitForNotificationEvent( &completionEvent );
            
            //
            // the status code must be valid
            //
            assert( kIOReturnInvalid != completionEvent );
            
        } else if( shadowed ){
            
            //
            // an asynchronous shadowing, the first phase was successful
            //
            assert( !synchronousShadow );
            assert( DLD_INVALID_EVENT_VALUE == completionEvent );
            
            shadowCompletionRC = KERN_SUCCESS;
            
        } else {
            
            //
            // failed on the first phase
            //
            DBG_PRINT_ERROR(("the first phase of the shadowing failed\n"));
            shadowCompletionRC = KERN_FAILURE;
        }
        
        if( KERN_SUCCESS != shadowCompletionRC && gSecuritySettings.securitySettings.disableOnShadowErrors ){
            
            //
            // the shadowing failed so must the request
            //
            DBG_PRINT_ERROR(("shadowing failed\n"));
            disable = true;
        }
        
        //
        // the SCSI operation completion status is reported by a completion callback hook, see shadowSCSIOperation()
        //
        
    }// end if( isShadowedUser )
    
    
__exit:
    assert( dldSCSIDev );
    dldSCSIDev->release();
    
    if( disable )
        DldSCSITaskCompleteAccessDenied( request );
    
    return (!disable);
}

//--------------------------------------------------------------------